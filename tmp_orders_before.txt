const pool = require('../db');

// Create orders tables if they don't exist
async function initOrdersTables() {
  try {
    // Create orders table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS orders (
        id SERIAL PRIMARY KEY,
        order_number VARCHAR(20) UNIQUE NOT NULL,
        customer_name VARCHAR(100),
        table_number VARCHAR(20),
        order_type VARCHAR(20) DEFAULT 'dine-in',
        payment_method VARCHAR(20) DEFAULT 'Cash',
        notes TEXT,
        subtotal DECIMAL(10,2) NOT NULL,
        discount DECIMAL(10,2) DEFAULT 0.00,
        total DECIMAL(10,2) NOT NULL,
        amount_received DECIMAL(10,2) DEFAULT 0.00,
        change_amount DECIMAL(10,2) DEFAULT 0.00,
        status VARCHAR(20) DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        completed_at TIMESTAMP
      );
    `);

    // Create order_items table
    await pool.query(`
      CREATE TABLE IF NOT EXISTS order_items (
        id SERIAL PRIMARY KEY,
        order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,
        product_id INTEGER REFERENCES inventory_items(id),
        product_name VARCHAR(100) NOT NULL,
        quantity INTEGER NOT NULL,
        unit_price DECIMAL(10,2) NOT NULL,
        total_price DECIMAL(10,2) NOT NULL
      );
    `);

    console.log('Orders tables initialized successfully');
  } catch (error) {
    console.error('Error initializing orders tables:', error);
    throw error;
  }
}

// Generate unique order number
async function generateOrderNumber() {
  const result = await pool.query(
    "SELECT COUNT(*) as count FROM orders WHERE DATE(created_at) = CURRENT_DATE"
  );
  const todayCount = parseInt(result.rows[0].count) + 1;
  const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
  return `${date}-${todayCount.toString().padStart(3, '0')}`;
}

// Create a new order
async function createOrder(orderData) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // Generate order number
    const orderNumber = await generateOrderNumber();
    
    // Create order
    const orderResult = await client.query(
      `INSERT INTO orders (
        order_number, customer_name, table_number, order_type, payment_method, 
        notes, subtotal, discount, total, amount_received, change_amount, status
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) RETURNING *`,
      [
        orderNumber,
        orderData.customerName || null,
        orderData.tableNumber || null,
        orderData.orderType || 'dine-in',
        orderData.paymentMethod || 'Cash',
        orderData.notes || null,
        orderData.subtotal,
        orderData.discount || 0,
        orderData.total,
        orderData.amountReceived || 0,
        orderData.changeAmount || 0,
        'pending'
      ]
    );
    
    const order = orderResult.rows[0];
    
    // Add order items
    for (const item of orderData.items) {
      await client.query(
        `INSERT INTO order_items (order_id, product_id, product_name, quantity, unit_price, total_price)
         VALUES ($1, $2, $3, $4, $5, $6)`,
        [
          order.id,
          item.id,
          item.name,
          item.quantity,
          item.price,
          item.price * item.quantity
        ]
      );
    }
    
    await client.query('COMMIT');
    return order;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Get all orders
async function getAllOrders() {
  const result = await pool.query(`
    SELECT 
      o.*,
      json_agg(
        json_build_object(
          'id', oi.id,
          'product_id', oi.product_id,
          'product_name', oi.product_name,
          'quantity', oi.quantity,
          'unit_price', oi.unit_price,
          'total_price', oi.total_price
        )
      ) as items
    FROM orders o
    LEFT JOIN order_items oi ON o.id = oi.order_id
    GROUP BY o.id
    ORDER BY o.created_at DESC
  `);
  return result.rows;
}

// Get order by ID
async function getOrderById(id) {
  const result = await pool.query(`
    SELECT 
      o.*,
      json_agg(
        json_build_object(
          'id', oi.id,
          'product_id', oi.product_id,
          'product_name', oi.product_name,
          'quantity', oi.quantity,
          'unit_price', oi.unit_price,
          'total_price', oi.total_price
        )
      ) as items
    FROM orders o
    LEFT JOIN order_items oi ON o.id = oi.order_id
    WHERE o.id = $1
    GROUP BY o.id
  `, [id]);
  return result.rows[0];
}

// Update order status
async function updateOrderStatus(id, status) {
  // Update status first
  const updated = await pool.query(
    `UPDATE orders SET status = $1 WHERE id = $2 RETURNING *`,
    [status, id]
  );
  const order = updated.rows[0];
  if (!order) return null;

  // If completed, set completed_at separately to avoid type inference issues
  if (String(status) === 'completed') {
    const completedRes = await pool.query(
      `UPDATE orders SET completed_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING *`,
      [id]
    );
    return completedRes.rows[0];
  }
  return order;
}

// Get orders by status
async function getOrdersByStatus(status) {
  const result = await pool.query(`
    SELECT 
      o.*,
      json_agg(
        json_build_object(
          'id', oi.id,
          'product_id', oi.product_id,
          'product_name', oi.product_name,
          'quantity', oi.quantity,
          'unit_price', oi.unit_price,
          'total_price', oi.total_price
        )
      ) as items
    FROM orders o
    LEFT JOIN order_items oi ON o.id = oi.order_id
    WHERE o.status = $1
    GROUP BY o.id
    ORDER BY o.created_at ASC
  `, [status]);
  return result.rows;
}

// Void order - only allowed for pending orders
async function voidOrder(id) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // First check if order exists and is pending
    const orderCheck = await client.query(
      'SELECT status FROM orders WHERE id = $1',
      [id]
    );
    
    if (orderCheck.rows.length === 0) {
      throw new Error('Order not found');
    }
    
    if (orderCheck.rows[0].status !== 'pending') {
      throw new Error('Order can only be voided when status is pending');
    }
    
    // Update order status to cancelled
    const result = await client.query(
      'UPDATE orders SET status = $1 WHERE id = $2 RETURNING *',
      ['cancelled', id]
    );
    
    await client.query('COMMIT');
    return result.rows[0];
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Update order (items, notes, and table number) - only allowed for pending orders
async function updateOrder(id, orderData) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // First check if order exists and is pending
    const orderCheck = await client.query(
      'SELECT status FROM orders WHERE id = $1',
      [id]
    );
    
    if (orderCheck.rows.length === 0) {
      throw new Error('Order not found');
    }
    
    if (orderCheck.rows[0].status !== 'pending') {
      throw new Error('Order can only be edited when status is pending');
    }
    
    // Update order notes if provided
    if (orderData.notes !== undefined) {
      await client.query(
        'UPDATE orders SET notes = $1 WHERE id = $2',
        [orderData.notes, id]
      );
    }

    // Update table number if provided (allow switching tables for dine-in)
    const incomingTable = orderData.table_number !== undefined ? orderData.table_number : orderData.tableNumber;
    if (incomingTable !== undefined) {
      const value = (incomingTable === null || String(incomingTable).trim() === '') ? null : parseInt(String(incomingTable).trim(), 10);
      if (value !== null && Number.isNaN(value)) {
        throw new Error('Invalid table number');
      }
      if (value !== null) {
        // Validate against dining_tables to prevent assigning to occupied
        const tRes = await client.query('SELECT status FROM dining_tables WHERE table_number = $1', [value]);
        if (tRes.rows.length === 0) {
          throw new Error('Invalid table number');
        }
        if (tRes.rows[0].status !== 'available') {
          throw new Error('Selected table is occupied');
        }
      }
      await client.query('UPDATE orders SET table_number = $1 WHERE id = $2', [value, id]);
      if (value !== null) {
        await client.query('UPDATE dining_tables SET status = \'occupied\', updated_at = NOW() WHERE table_number = $1', [value]);
      }
    }
    
    // If items are provided, update them
    if (orderData.items && orderData.items.length > 0) {
      // Delete existing order items
      await client.query('DELETE FROM order_items WHERE order_id = $1', [id]);
      
      // Add new order items
      for (const item of orderData.items) {
        await client.query(
          `INSERT INTO order_items (order_id, product_id, product_name, quantity, unit_price, total_price)
           VALUES ($1, $2, $3, $4, $5, $6)`,
          [
            id,
            item.product_id || item.id,
            item.product_name,
            item.quantity,
            item.unit_price,
            item.unit_price * item.quantity
          ]
        );
      }
      
      // Recalculate totals
      const itemsTotal = await client.query(
        'SELECT SUM(total_price) as total FROM order_items WHERE order_id = $1',
        [id]
      );
      
      const newTotal = parseFloat(itemsTotal.rows[0].total || 0);
      const discount = orderData.discount || 0;
      const finalTotal = newTotal - discount;
      
      await client.query(
        'UPDATE orders SET subtotal = $1, discount = $2, total = $3 WHERE id = $4',
        [newTotal, discount, finalTotal, id]
      );
    }
    
    await client.query('COMMIT');
    
    // Return updated order
    return await getOrderById(id);
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

module.exports = {
  initOrdersTables,
  createOrder,
  getAllOrders,
  getOrderById,
  updateOrderStatus,
  getOrdersByStatus,
  updateOrder,
  voidOrder,
}; 

